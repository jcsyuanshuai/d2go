# Runtime

## 编译

## 内存

逃逸分析

内存分配

## 并发

1. `context`是什么？有什么的作用？
2.

## 调度

1. 进程和线程的区别。
2. goroutine 和线程的区别。
3. 那些情况下会发生goroutine调度？
4. GMP调度模型。
5. G0是什么？

## GC

GC，是一种**自动内存管理**机制，通常GC的执行可以划分为两个过程，标记和清除。**根对象**是在GC中标记过程中最先检查的对象，包括全局变量、执行栈、寄存器。常见的GC实现方式可以归结为**追踪**和**引用计数**以及这两种方式的混合。Go语言中采用追踪方式中的**三色标记清除**算法，步骤如下：

- 第一步，程序初始化以及每次创建新对象，默认标记为白色。
- 第二步，每次GC开始会从根对象遍历所有可抵达的对象，把遍历到的对象标记为灰色。
- 第三步，遍历灰色对象，将其可抵达的对象标记为灰色，再将其自身标记为黑色。
- 第四步，重复第三步，直到没有灰色对象，此时，只有黑色对象和白色对象。
- 第五步，回收所有白色对象。

**STW**，为了防止用户程序的运行影响三色标记算法，从而在GC开始前停止用户程序goroutine，在用户视角来看就是整个程序世界停止了(卡顿)。如果不启动STW，用户程序可能改变对象引用，以下的两种情况会导致对象丢失：

- 白色对象被黑色对象引用
- 灰色对象丢失白色对象应用

**屏障机制**，为了不启用STW的情况下保证对象不丢失方法，可分为**强三色不变式**和**弱三色不变式**，前者不允许存在黑色对象引用白色对象的指针，后者允许但是需要白色对象处于灰色对象的引用下。

- 插入屏障
- 删除屏障
- 混合屏障
