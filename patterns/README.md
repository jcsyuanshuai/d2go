# 设计模式

## 创建型

### 单例模式

定义：一个类只允许创建一个对象(实例)，那这个类就是单例类，创建单例类的模式就是单例模式。

用处：从业务概念上，有些数据在系统中只应该保存一份。

难点： 如何实现唯一性

1. 进程之间唯一
2. 线程之间唯一
3. 集群之间唯一

问题

- 对OOP的特性支持不友好
- 会隐藏类之间的依赖关系
  - 降低可读性
  - 通过构造函数、参数传递等方式声明的类之间的依赖关系，
- 对代码扩展性不友好
  - 如果一天需要创建多个实例会比较麻烦
- 对代码的可测性不友好
  - 单例是硬编码的模式，不利于`mock`
  - 可以通过将单例类型作为参数传递给需要的方法解决可观测性问题
- 不支持有参数的构造函数

## 工厂模式

工厂模式使用场景

1. 封装变化：创建逻辑的变更对调用者透明
2. 代码复用：创建代码抽离到独立的工厂类之后可以复用
3. 隔离复杂性：封装复杂的创建逻辑，调用者无须了解如何创建对象，如初始化顺序，依赖关系，字段检测
4. 控制复杂度：将创建代码抽离出来，让原本的函数或类职责更单一，代码更简洁

依赖注入

最基本的设计基于工厂模式

一个工厂类负责某个类或者一组相关类(实现同一接口)对象的创建，其中 DIC 负责整个应用中所有类对象的创建。

DIC 的核心功能

- 配置解析
- 对象创建
  - 涉及工厂模式
  - 利用反射创建对象
  - 利用递归解决对象依赖？
  - 循环依赖问题
    - 构造器：
    - setter：单例缓存 对象生命周期管理

## 建造者模式

应用场景

1. 类中属性较多
2. 类中属性之间有依赖关系，或者是约束条件
3. 存在必选和非必选的属性
4. 希望创建不可变的对象

和工厂模式区别

工厂模式：用于创建类型相关的不同对象

建造者模式：用于创建参数复杂的对象

## 原型模式

定义：利用已有对象(原型)进行复制(clone)的方式来创建新对象，已达到节省创建时间的目的。

场景：对象创建成本比较大，如对象数据需要经过复杂的计算，排序，hash等，或者需要从rpc、网络、数据库等慢io中获取并且同一个类的不同对象之间差别不大(大部分字段相同)

实现：深拷贝，复制数据和值，浅拷贝，复制对象引用，可能会引起对象改变

## 设计原则

- KISS
  - 尽量保持简单
    - 逻辑复杂度
    - 实现难度
    - 代码可读性
  - 常见原则
    - 不要使用同事可能不懂得技术来实现代码
    - 不要重复造轮子，善于使用已经有的工具
    - 不要过度优化 YAGNI
- DRY
  - 不要重复自己
  -
- LOD
- SOLID
  - 单一职责
  - 开闭原则
  - 里式替换
  - 接口隔离
  - 依赖倒置

## 结构型



## 行为型